// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: player.sql

package queries

import (
	"context"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO player (
	accountid,
	score,
	isready,
	art
) VALUES (
	$1,
	$2,
	$3,
	$4
)
RETURNING id, accountid, score, isready, art
`

type CreatePlayerParams struct {
	Accountid int
	Score     int
	Isready   bool
	Art       string
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.Accountid,
		arg.Score,
		arg.Isready,
		arg.Art,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
	)
	return i, err
}

const getPlayerById = `-- name: GetPlayerById :one
SELECT player.id, player.accountid, player.score, player.isready, player.art FROM player WHERE id=$1 LIMIT 1
`

func (q *Queries) GetPlayerById(ctx context.Context, id int) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerById, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
	)
	return i, err
}

const getPlayerByMatchAndAccountId = `-- name: GetPlayerByMatchAndAccountId :one
SELECT 
    player.id, player.accountid, player.score, player.isready, player.art
FROM
    player
LEFT JOIN
    match_player ON player.id=match_player.playerid
WHERE
    match_player.matchid = $1 AND player.accountid = $2
`

type GetPlayerByMatchAndAccountIdParams struct {
	Matchid   int
	Accountid int
}

func (q *Queries) GetPlayerByMatchAndAccountId(ctx context.Context, arg GetPlayerByMatchAndAccountIdParams) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByMatchAndAccountId, arg.Matchid, arg.Accountid)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
	)
	return i, err
}

const playerJoinMatch = `-- name: PlayerJoinMatch :exec
INSERT INTO 
    match_player (matchid, playerid)     
VALUES 
    ($1, $2)
`

type PlayerJoinMatchParams struct {
	Matchid  int
	Playerid int
}

func (q *Queries) PlayerJoinMatch(ctx context.Context, arg PlayerJoinMatchParams) error {
	_, err := q.db.Exec(ctx, playerJoinMatch, arg.Matchid, arg.Playerid)
	return err
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE player SET 
		score = $1, 
		isReady = $2,
		art = $3 
	WHERE 
		id = $4
    RETURNING id, accountid, score, isready, art
`

type UpdatePlayerParams struct {
	Score   int
	Isready bool
	Art     string
	ID      int
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayer,
		arg.Score,
		arg.Isready,
		arg.Art,
		arg.ID,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
	)
	return i, err
}

const updatePlayerReady = `-- name: UpdatePlayerReady :exec
UPDATE player SET isReady = $1 WHERE id = $2
`

type UpdatePlayerReadyParams struct {
	Isready bool
	ID      int
}

func (q *Queries) UpdatePlayerReady(ctx context.Context, arg UpdatePlayerReadyParams) error {
	_, err := q.db.Exec(ctx, updatePlayerReady, arg.Isready, arg.ID)
	return err
}

const updatePlayerTurnOrder = `-- name: UpdatePlayerTurnOrder :exec
UPDATE match_player SET turnorder = $1 WHERE matchid = $2 AND playerid = $3
`

type UpdatePlayerTurnOrderParams struct {
	Turnorder int
	Matchid   int
	Playerid  int
}

func (q *Queries) UpdatePlayerTurnOrder(ctx context.Context, arg UpdatePlayerTurnOrderParams) error {
	_, err := q.db.Exec(ctx, updatePlayerTurnOrder, arg.Turnorder, arg.Matchid, arg.Playerid)
	return err
}
