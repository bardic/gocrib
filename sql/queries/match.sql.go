// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: match.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO match(
    privateMatch,
    eloRangeMin,
    eloRangeMax,
    cutGameCardId,
    turnPassTimestamps,
    dealerId,
    gameState,
    art)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
  $8)
RETURNING id, creationdate, privatematch, elorangemin, elorangemax, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art
`

type CreateMatchParams struct {
	Privatematch       bool
	Elorangemin        int
	Elorangemax        int
	Cutgamecardid      int
	Turnpasstimestamps []pgtype.Timestamptz
	Dealerid           int
	Gamestate          string
	Art                string
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.Privatematch,
		arg.Elorangemin,
		arg.Elorangemax,
		arg.Cutgamecardid,
		arg.Turnpasstimestamps,
		arg.Dealerid,
		arg.Gamestate,
		arg.Art,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.Creationdate,
		&i.Privatematch,
		&i.Elorangemin,
		&i.Elorangemax,
		&i.Cutgamecardid,
		&i.Dealerid,
		&i.Currentplayerturn,
		&i.Turnpasstimestamps,
		&i.Gamestate,
		&i.Art,
	)
	return i, err
}

const getDeckForMatchId = `-- name: GetDeckForMatchId :many
SELECT 
    deck.id, deck.cutmatchcardid, deck.matchid,
    matchcard.id, matchcard.cardid, matchcard.origowner, matchcard.currowner, matchcard.state, matchcard.deckid,
    card.id, card.value, card.suit, card.art
FROM
    matchcard
LEFT JOIN
    deck ON matchcard.deckid=deck.id
LEFT JOIN
    match ON deck.matchid=match.id
left join 
	card on card.id=matchcard.cardid
WHERE
    match.id = $1
`

type GetDeckForMatchIdRow struct {
	ID             int
	Cutmatchcardid int
	Matchid        int
	ID_2           int
	Cardid         int
	Origowner      int
	Currowner      int
	State          string
	Deckid         int
	ID_3           int
	Value          NullCardvalue
	Suit           NullCardsuit
	Art            pgtype.Text
}

func (q *Queries) GetDeckForMatchId(ctx context.Context, id int) ([]GetDeckForMatchIdRow, error) {
	rows, err := q.db.Query(ctx, getDeckForMatchId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeckForMatchIdRow
	for rows.Next() {
		var i GetDeckForMatchIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Cutmatchcardid,
			&i.Matchid,
			&i.ID_2,
			&i.Cardid,
			&i.Origowner,
			&i.Currowner,
			&i.State,
			&i.Deckid,
			&i.ID_3,
			&i.Value,
			&i.Suit,
			&i.Art,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchById = `-- name: GetMatchById :one
SELECT
    json_build_object(
        'id', id,
        'creationDate', creationDate,
        'privateMatch', privateMatch,
        'eloRangeMin', eloRangeMin,
        'eloRangeMax', eloRangeMax,
        'deckid', deckid,
        'cutgamecardid', cutgamecardid,
        'dealerid', dealerid,
        'currentplayerturn', currentplayerturn,
        'turnpasstimestamps', turnpasstimestamps,
        'gameState', gameState,
        'art', art,
        'players',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', p.id,
                        'accountid', p.accountid,
                        'score', p.score,
                        'isready', p.isready,
                        'art', p.art
                    )
                )
            FROM player AS p
            LEFT JOIN
                match_player as mp ON p.id=mp.playerid and mp.matchid=m.id
            WHERE p.Id = mp.playerId
        )
    )
FROM match AS m
LEFT JOIN
    match_player as mp ON m.id=mp.matchid
WHERE m.id = $1
LIMIT 1
`

func (q *Queries) GetMatchById(ctx context.Context, id int) ([]byte, error) {
	row := q.db.QueryRow(ctx, getMatchById, id)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getMatchCurrentPlayerTurn = `-- name: GetMatchCurrentPlayerTurn :one
SELECT currentplayerturn FROM match WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMatchCurrentPlayerTurn(ctx context.Context, id int) (int, error) {
	row := q.db.QueryRow(ctx, getMatchCurrentPlayerTurn, id)
	var currentplayerturn int
	err := row.Scan(&currentplayerturn)
	return currentplayerturn, err
}

const getMatchStateById = `-- name: GetMatchStateById :one
SELECT 
    match.gameState
FROM
    match
WHERE
    match.id = $1
`

func (q *Queries) GetMatchStateById(ctx context.Context, id int) (string, error) {
	row := q.db.QueryRow(ctx, getMatchStateById, id)
	var gamestate string
	err := row.Scan(&gamestate)
	return gamestate, err
}

const getNextPlayerInTurnOrder = `-- name: GetNextPlayerInTurnOrder :one
SELECT 
    player.id, player.accountid, player.score, player.isready, player.art,
    match_player.turnorder
FROM
    player
LEFT JOIN
    match_player ON player.id=match_player.playerid
WHERE
    match_player.matchid = $1 AND match_player.turnorder = $2 + 1
`

type GetNextPlayerInTurnOrderParams struct {
	Matchid int
	Column2 interface{}
}

type GetNextPlayerInTurnOrderRow struct {
	ID        int
	Accountid int
	Score     int
	Isready   bool
	Art       string
	Turnorder int
}

func (q *Queries) GetNextPlayerInTurnOrder(ctx context.Context, arg GetNextPlayerInTurnOrderParams) (GetNextPlayerInTurnOrderRow, error) {
	row := q.db.QueryRow(ctx, getNextPlayerInTurnOrder, arg.Matchid, arg.Column2)
	var i GetNextPlayerInTurnOrderRow
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
		&i.Turnorder,
	)
	return i, err
}

const getOpenMatches = `-- name: GetOpenMatches :many
SELECT id, creationdate, privatematch, elorangemin, elorangemax, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art FROM match WHERE gameState=$1
`

func (q *Queries) GetOpenMatches(ctx context.Context, gamestate string) ([]Match, error) {
	rows, err := q.db.Query(ctx, getOpenMatches, gamestate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.Creationdate,
			&i.Privatematch,
			&i.Elorangemin,
			&i.Elorangemax,
			&i.Cutgamecardid,
			&i.Dealerid,
			&i.Currentplayerturn,
			&i.Turnpasstimestamps,
			&i.Gamestate,
			&i.Art,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersForMatchId = `-- name: GetPlayersForMatchId :many
SELECT
    json_build_object(
        'id', p.id,
        'accountid', p.accountid,
        'score', p.score,
        'isready', p.isready,
        'art', p.art,
        'hand',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.currowner = p.id AND m.state = 'Hand'
        ),
        'kitty',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.currowner = p.id AND m.state = 'Kitty'
        ),
        'play',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.state = 'Play'
        )
    )
FROM player as p
LEFT JOIN
    match_player ON p.id=match_player.playerid
WHERE
    match_player.matchid = $1
`

func (q *Queries) GetPlayersForMatchId(ctx context.Context, matchid int) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getPlayersForMatchId, matchid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var json_build_object []byte
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetDeckForMatchId = `-- name: ResetDeckForMatchId :exec
UPDATE matchcard m SET state = 'Deck', origowner = null, currowner = null FROM matchcard
LEFT JOIN
    deck ON matchcard.deckid=deck.id
LEFT JOIN
    match ON deck.matchId=match.id
WHERE
    match.id = $1
`

func (q *Queries) ResetDeckForMatchId(ctx context.Context, id int) error {
	_, err := q.db.Exec(ctx, resetDeckForMatchId, id)
	return err
}

const upateMatchCurrentPlayerTurn = `-- name: UpateMatchCurrentPlayerTurn :exec
UPDATE match SET currentplayerturn = $1 WHERE id = $2
`

type UpateMatchCurrentPlayerTurnParams struct {
	Currentplayerturn int
	ID                int
}

func (q *Queries) UpateMatchCurrentPlayerTurn(ctx context.Context, arg UpateMatchCurrentPlayerTurnParams) error {
	_, err := q.db.Exec(ctx, upateMatchCurrentPlayerTurn, arg.Currentplayerturn, arg.ID)
	return err
}

const updateDealerForMatch = `-- name: UpdateDealerForMatch :exec
UPDATE match SET dealerid = $1 WHERE id = $2
`

type UpdateDealerForMatchParams struct {
	Dealerid int
	ID       int
}

func (q *Queries) UpdateDealerForMatch(ctx context.Context, arg UpdateDealerForMatchParams) error {
	_, err := q.db.Exec(ctx, updateDealerForMatch, arg.Dealerid, arg.ID)
	return err
}

const updateMatch = `-- name: UpdateMatch :exec
UPDATE match SET
	creationDate = $1,
	privateMatch = $2,
	eloRangeMin = $3,
	eloRangeMax = $4,
	cutGameCardId = $5,
  dealerId = $6,
	currentPlayerTurn = $7,
	turnPassTimestamps = $8,
	gameState= $9,
	art = $10
WHERE id=$11
`

type UpdateMatchParams struct {
	Creationdate       pgtype.Timestamptz
	Privatematch       bool
	Elorangemin        int
	Elorangemax        int
	Cutgamecardid      int
	Dealerid           int
	Currentplayerturn  int
	Turnpasstimestamps []pgtype.Timestamptz
	Gamestate          string
	Art                string
	ID                 int
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) error {
	_, err := q.db.Exec(ctx, updateMatch,
		arg.Creationdate,
		arg.Privatematch,
		arg.Elorangemin,
		arg.Elorangemax,
		arg.Cutgamecardid,
		arg.Dealerid,
		arg.Currentplayerturn,
		arg.Turnpasstimestamps,
		arg.Gamestate,
		arg.Art,
		arg.ID,
	)
	return err
}

const updateMatchCut = `-- name: UpdateMatchCut :exec
UPDATE match SET cutGameCardId= $1 WHERE id=$2
`

type UpdateMatchCutParams struct {
	Cutgamecardid int
	ID            int
}

func (q *Queries) UpdateMatchCut(ctx context.Context, arg UpdateMatchCutParams) error {
	_, err := q.db.Exec(ctx, updateMatchCut, arg.Cutgamecardid, arg.ID)
	return err
}

const updateMatchState = `-- name: UpdateMatchState :one
UPDATE match SET gameState= $1 WHERE id=$2 RETURNING id, creationdate, privatematch, elorangemin, elorangemax, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art
`

type UpdateMatchStateParams struct {
	Gamestate string
	ID        int
}

func (q *Queries) UpdateMatchState(ctx context.Context, arg UpdateMatchStateParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatchState, arg.Gamestate, arg.ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.Creationdate,
		&i.Privatematch,
		&i.Elorangemin,
		&i.Elorangemax,
		&i.Cutgamecardid,
		&i.Dealerid,
		&i.Currentplayerturn,
		&i.Turnpasstimestamps,
		&i.Gamestate,
		&i.Art,
	)
	return i, err
}
