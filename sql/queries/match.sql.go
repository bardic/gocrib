// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: match.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMatch = `-- name: CreateMatch :one
INSERT INTO match(
    privateMatch,
    eloRangeMin,
    eloRangeMax,
    deckId,
    cutGameCardId,
    turnPassTimestamps,
    gameState,
    art)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8)
RETURNING id, creationdate, privatematch, elorangemin, elorangemax, deckid, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art
`

type CreateMatchParams struct {
	Privatematch       bool
	Elorangemin        *int
	Elorangemax        *int
	Deckid             *int
	Cutgamecardid      *int
	Turnpasstimestamps []pgtype.Timestamptz
	Gamestate          Gamestate
	Art                string
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.Privatematch,
		arg.Elorangemin,
		arg.Elorangemax,
		arg.Deckid,
		arg.Cutgamecardid,
		arg.Turnpasstimestamps,
		arg.Gamestate,
		arg.Art,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.Creationdate,
		&i.Privatematch,
		&i.Elorangemin,
		&i.Elorangemax,
		&i.Deckid,
		&i.Cutgamecardid,
		&i.Dealerid,
		&i.Currentplayerturn,
		&i.Turnpasstimestamps,
		&i.Gamestate,
		&i.Art,
	)
	return i, err
}

const getMatchById = `-- name: GetMatchById :one
SELECT
    json_build_object(
        'id', id,
        'creationDate', creationDate,
        'privateMatch', privateMatch,
        'eloRangeMin', eloRangeMin,
        'eloRangeMax', eloRangeMax,
        'deckid', deckid,
        'cutgamecardid', cutgamecardid,
        'dealerid', dealerid,
        'currentplayerturn', currentplayerturn,
        'turnpasstimestamps', turnpasstimestamps,
        'gameState', gameState,
        'art', art,
        'players',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', p.id,
                        'accountid', p.accountid,
                        'score', p.score,
                        'isready', p.isready,
                        'art', p.art
                    )
                )
            FROM player AS p
            LEFT JOIN
                match_player as mp ON p.id=mp.playerid and mp.matchid=m.id
            WHERE p.Id = mp.playerId
        )
    )
FROM match AS m
LEFT JOIN
    match_player as mp ON m.id=mp.matchid
WHERE m.id = $1
LIMIT 1
`

func (q *Queries) GetMatchById(ctx context.Context, id *int) ([]byte, error) {
	row := q.db.QueryRow(ctx, getMatchById, id)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getMatchCurrentPlayerTurn = `-- name: GetMatchCurrentPlayerTurn :one
SELECT currentplayerturn FROM match WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMatchCurrentPlayerTurn(ctx context.Context, id *int) (*int, error) {
	row := q.db.QueryRow(ctx, getMatchCurrentPlayerTurn, id)
	var currentplayerturn *int
	err := row.Scan(&currentplayerturn)
	return currentplayerturn, err
}

const getMatchDealer = `-- name: GetMatchDealer :one
SELECT 
    player.id, player.accountid, player.score, player.isready, player.art
FROM
    player
LEFT JOIN
    match ON player.id=match.dealerid
WHERE
    match.id = $1
`

func (q *Queries) GetMatchDealer(ctx context.Context, id *int) (Player, error) {
	row := q.db.QueryRow(ctx, getMatchDealer, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
	)
	return i, err
}

const getMatchForPlayerId = `-- name: GetMatchForPlayerId :one
SELECT 
    match_player.matchid, match_player.playerid, match_player.turnorder,
    match.id, match.creationdate, match.privatematch, match.elorangemin, match.elorangemax, match.deckid, match.cutgamecardid, match.dealerid, match.currentplayerturn, match.turnpasstimestamps, match.gamestate, match.art,
    player.id, player.accountid, player.score, player.isready, player.art
FROM 
    match_player
INNER JOIN
    match ON match_player.matchid=match.id
LEFT JOIN
    player ON match_player.playerid=player.id
WHERE $1 = match_player.playerId LIMIT 1
`

type GetMatchForPlayerIdRow struct {
	Matchid            *int
	Playerid           *int
	Turnorder          *int
	ID                 *int
	Creationdate       pgtype.Timestamptz
	Privatematch       bool
	Elorangemin        *int
	Elorangemax        *int
	Deckid             *int
	Cutgamecardid      *int
	Dealerid           *int
	Currentplayerturn  *int
	Turnpasstimestamps []pgtype.Timestamptz
	Gamestate          Gamestate
	Art                string
	ID_2               *int
	Accountid          *int
	Score              *int
	Isready            pgtype.Bool
	Art_2              pgtype.Text
}

func (q *Queries) GetMatchForPlayerId(ctx context.Context, playerid *int) (GetMatchForPlayerIdRow, error) {
	row := q.db.QueryRow(ctx, getMatchForPlayerId, playerid)
	var i GetMatchForPlayerIdRow
	err := row.Scan(
		&i.Matchid,
		&i.Playerid,
		&i.Turnorder,
		&i.ID,
		&i.Creationdate,
		&i.Privatematch,
		&i.Elorangemin,
		&i.Elorangemax,
		&i.Deckid,
		&i.Cutgamecardid,
		&i.Dealerid,
		&i.Currentplayerturn,
		&i.Turnpasstimestamps,
		&i.Gamestate,
		&i.Art,
		&i.ID_2,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art_2,
	)
	return i, err
}

const getMatchNextPlayerForMatchId = `-- name: GetMatchNextPlayerForMatchId :one
SELECT 
    player.id, player.accountid, player.score, player.isready, player.art,
    match_player.turnorder
FROM
    player
LEFT JOIN
    match_player ON player.id=match_player.playerid
WHERE
    match_player.matchid = $1 AND match_player.turnorder = $2 + 1
`

type GetMatchNextPlayerForMatchIdParams struct {
	Matchid *int
	Column2 interface{}
}

type GetMatchNextPlayerForMatchIdRow struct {
	ID        *int
	Accountid *int
	Score     *int
	Isready   bool
	Art       string
	Turnorder *int
}

// TODO this takes a second param. PRetty sure we can get that from the match object
func (q *Queries) GetMatchNextPlayerForMatchId(ctx context.Context, arg GetMatchNextPlayerForMatchIdParams) (GetMatchNextPlayerForMatchIdRow, error) {
	row := q.db.QueryRow(ctx, getMatchNextPlayerForMatchId, arg.Matchid, arg.Column2)
	var i GetMatchNextPlayerForMatchIdRow
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
		&i.Turnorder,
	)
	return i, err
}

const getNextPlayerInTurnOrder = `-- name: GetNextPlayerInTurnOrder :one
SELECT 
    player.id, player.accountid, player.score, player.isready, player.art,
    match_player.turnorder
FROM
    player
LEFT JOIN
    match_player ON player.id=match_player.playerid
WHERE
    match_player.matchid = $1 AND match_player.turnorder = $2 + 1
`

type GetNextPlayerInTurnOrderParams struct {
	Matchid *int
	Column2 interface{}
}

type GetNextPlayerInTurnOrderRow struct {
	ID        *int
	Accountid *int
	Score     *int
	Isready   bool
	Art       string
	Turnorder *int
}

func (q *Queries) GetNextPlayerInTurnOrder(ctx context.Context, arg GetNextPlayerInTurnOrderParams) (GetNextPlayerInTurnOrderRow, error) {
	row := q.db.QueryRow(ctx, getNextPlayerInTurnOrder, arg.Matchid, arg.Column2)
	var i GetNextPlayerInTurnOrderRow
	err := row.Scan(
		&i.ID,
		&i.Accountid,
		&i.Score,
		&i.Isready,
		&i.Art,
		&i.Turnorder,
	)
	return i, err
}

const getOpenMatches = `-- name: GetOpenMatches :many
SELECT id, creationdate, privatematch, elorangemin, elorangemax, deckid, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art FROM match WHERE gameState=$1
`

func (q *Queries) GetOpenMatches(ctx context.Context, gamestate Gamestate) ([]Match, error) {
	rows, err := q.db.Query(ctx, getOpenMatches, gamestate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Match
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.Creationdate,
			&i.Privatematch,
			&i.Elorangemin,
			&i.Elorangemax,
			&i.Deckid,
			&i.Cutgamecardid,
			&i.Dealerid,
			&i.Currentplayerturn,
			&i.Turnpasstimestamps,
			&i.Gamestate,
			&i.Art,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayersForMatchId = `-- name: GetPlayersForMatchId :many
SELECT
    json_build_object(
        'id', p.id,
        'accountid', p.accountid,
        'score', p.score,
        'isready', p.isready,
        'art', p.art,
        'hand',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.currowner = p.id AND m.state = 'Hand'
        ),
        'kitty',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.currowner = p.id AND m.state = 'Kitty'
        ),
        'play',
        (
            SELECT
                json_agg(
                    json_build_object(
                        'id', m.id,
                        'cardid', m.cardid,
                        'origowner', m.origowner,
                        'currowner', m.currowner,
                        'state', m.state
                    )
                )
            FROM matchcard AS m
            WHERE m.state = 'Play'
        )
    )
FROM player as p
LEFT JOIN
    match_player ON p.id=match_player.playerid
WHERE
    match_player.matchid = $1
`

func (q *Queries) GetPlayersForMatchId(ctx context.Context, matchid *int) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getPlayersForMatchId, matchid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var json_build_object []byte
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetDeckForMatchId = `-- name: ResetDeckForMatchId :exec
UPDATE matchcard m SET state = 'Deck', origowner = null, currowner = null FROM matchcard
LEFT JOIN 
    deck_matchcard ON matchcard.id=deck_matchcard.matchcardid
LEFT JOIN
    deck ON deck_matchcard.deckid=deck.id
LEFT JOIN
    match ON deck.id=match.deckid
WHERE
    match.id = $1
`

func (q *Queries) ResetDeckForMatchId(ctx context.Context, id *int) error {
	_, err := q.db.Exec(ctx, resetDeckForMatchId, id)
	return err
}

const upateMatchCurrentPlayerTurn = `-- name: UpateMatchCurrentPlayerTurn :exec
UPDATE match SET currentplayerturn = $1 WHERE id = $2
`

type UpateMatchCurrentPlayerTurnParams struct {
	Currentplayerturn *int
	ID                *int
}

func (q *Queries) UpateMatchCurrentPlayerTurn(ctx context.Context, arg UpateMatchCurrentPlayerTurnParams) error {
	_, err := q.db.Exec(ctx, upateMatchCurrentPlayerTurn, arg.Currentplayerturn, arg.ID)
	return err
}

const updateDealerForMatch = `-- name: UpdateDealerForMatch :exec
UPDATE match SET dealerid = $1 WHERE id = $2
`

type UpdateDealerForMatchParams struct {
	Dealerid *int
	ID       *int
}

func (q *Queries) UpdateDealerForMatch(ctx context.Context, arg UpdateDealerForMatchParams) error {
	_, err := q.db.Exec(ctx, updateDealerForMatch, arg.Dealerid, arg.ID)
	return err
}

const updateMatch = `-- name: UpdateMatch :exec
UPDATE match SET
	creationDate = $1,
	privateMatch = $2,
	eloRangeMin = $3,
	eloRangeMax = $4,
	deckId = $5,
	cutGameCardId = $6,
    dealerId = $7,
	currentPlayerTurn = $8,
	turnPassTimestamps = $9,
	gameState= $10,
	art = $11
WHERE id=$12
`

type UpdateMatchParams struct {
	Creationdate       pgtype.Timestamptz
	Privatematch       bool
	Elorangemin        *int
	Elorangemax        *int
	Deckid             *int
	Cutgamecardid      *int
	Dealerid           *int
	Currentplayerturn  *int
	Turnpasstimestamps []pgtype.Timestamptz
	Gamestate          Gamestate
	Art                string
	ID                 *int
}

func (q *Queries) UpdateMatch(ctx context.Context, arg UpdateMatchParams) error {
	_, err := q.db.Exec(ctx, updateMatch,
		arg.Creationdate,
		arg.Privatematch,
		arg.Elorangemin,
		arg.Elorangemax,
		arg.Deckid,
		arg.Cutgamecardid,
		arg.Dealerid,
		arg.Currentplayerturn,
		arg.Turnpasstimestamps,
		arg.Gamestate,
		arg.Art,
		arg.ID,
	)
	return err
}

const updateMatchCut = `-- name: UpdateMatchCut :exec
UPDATE match SET cutGameCardId= $1 WHERE id=$2
`

type UpdateMatchCutParams struct {
	Cutgamecardid *int
	ID            *int
}

func (q *Queries) UpdateMatchCut(ctx context.Context, arg UpdateMatchCutParams) error {
	_, err := q.db.Exec(ctx, updateMatchCut, arg.Cutgamecardid, arg.ID)
	return err
}

const updateMatchState = `-- name: UpdateMatchState :one
UPDATE match SET gameState= $1 WHERE id=$2 RETURNING id, creationdate, privatematch, elorangemin, elorangemax, deckid, cutgamecardid, dealerid, currentplayerturn, turnpasstimestamps, gamestate, art
`

type UpdateMatchStateParams struct {
	Gamestate Gamestate
	ID        *int
}

func (q *Queries) UpdateMatchState(ctx context.Context, arg UpdateMatchStateParams) (Match, error) {
	row := q.db.QueryRow(ctx, updateMatchState, arg.Gamestate, arg.ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.Creationdate,
		&i.Privatematch,
		&i.Elorangemin,
		&i.Elorangemax,
		&i.Deckid,
		&i.Cutgamecardid,
		&i.Dealerid,
		&i.Currentplayerturn,
		&i.Turnpasstimestamps,
		&i.Gamestate,
		&i.Art,
	)
	return i, err
}

const updateMatchWithDeckId = `-- name: UpdateMatchWithDeckId :exec
UPDATE match SET deckid = $1 where id = $2
`

type UpdateMatchWithDeckIdParams struct {
	Deckid *int
	ID     *int
}

func (q *Queries) UpdateMatchWithDeckId(ctx context.Context, arg UpdateMatchWithDeckIdParams) error {
	_, err := q.db.Exec(ctx, updateMatchWithDeckId, arg.Deckid, arg.ID)
	return err
}
